import pandas as pd

def safe_execute_code(code_string: str, df: pd.DataFrame) -> str:
    """
    Executes a string of pandas code in a restricted, safe environment.

    Args:
        code_string (str): The string of Python code generated by the AI.
        df (pd.DataFrame): The pandas DataFrame that the code will operate on.

    Returns:
        str: A string representation of the code's output or a formatted error message.
    """
    # This is the padded cell we're putting the AI's code in.
    # It only has access to pandas (as 'pd') and the dataframe (as 'df').
    # It can't access dangerous libraries like 'os' or 'subprocess'. It's on a leash.
    allowed_globals = {
        "pd": pd,
        "df": df
    }

    # This is an empty box. We'll run the code and tell it to put its
    # final answer in this box. We'll look for a variable named 'result'.
    local_scope = {}

    try:
        # We execute the code here. It runs using the globals we allowed
        # and puts any new variables it creates into 'local_scope'.
        exec(code_string, allowed_globals, local_scope)

        # We look for the 'result' variable in the box. If it's not there,
        # the AI failed its one job. If it is, we grab it.
        result = local_scope.get("result", "Execution failed: No 'result' variable was assigned by the code.")
        
        # We convert the final answer to a string so we can display it in the chat.
        return str(result)

    except Exception as e:
        # This is our safety net. If the AI writes garbage code that throws an
        # error, we catch it here instead of crashing the whole app.
        error_message = f"Execution Error: {e}"
        # We print it to our own console for debugging too.
        print(error_message)
        return error_message